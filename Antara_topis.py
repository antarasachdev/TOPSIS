# -*- coding: utf-8 -*-
"""Untitled30.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zzOrYyRArvWMCnKGtSbIOYRMzCo3xCzF
"""

import pandas as pd
import math
import numpy as np
import os

class Topsis:
    def __init__(self, filename):
        # Load the file based on extension
        if os.path.isfile(filename):
            if filename.endswith('.csv'):
                self.data = pd.read_csv(filename)
            elif filename.endswith('.xlsx'):
                self.data = pd.read_excel(filename)
            else:
                print("Unsupported file format. Please provide a CSV or XLSX file.")
                exit(1)
        else:
            print("File not found.")
            exit(1)

        # Extract the decision matrix
        self.decision_matrix = self.data.iloc[:, 1:].values.astype(float)  # Ensure numeric values
        self.features = len(self.decision_matrix[0])
        self.samples = len(self.decision_matrix)

    def evaluate(self, weights=None, impacts=None):
        if weights is None:
            weights = [1] * self.features
        if impacts is None:
            impacts = ["+"] * self.features

        d = self.decision_matrix
        features = self.features
        samples = self.samples

        # Normalize the decision matrix and apply weights
        for i in range(features):
            norm_factor = math.sqrt(sum(d[:, i] ** 2))
            for j in range(samples):
                d[j, i] = ((d[j, i] / norm_factor) * weights[i])

        # Debug: Print normalized matrix
        print("Normalized Decision Matrix:\n", d)

        # Calculate ideal best and worst
        ideal_best = []
        ideal_worst = []
        for i in range(features):
            if impacts[i] == "+":
                ideal_best.append(max(d[:, i]))
                ideal_worst.append(min(d[:, i]))
            else:
                ideal_best.append(min(d[:, i]))
                ideal_worst.append(max(d[:, i]))

        # Debug: Print ideal best and worst
        print("Ideal Best:", ideal_best)
        print("Ideal Worst:", ideal_worst)

        # Calculate distances to ideal best and worst
        scores = []
        for i in range(samples):
            distance_best = math.sqrt(sum((d[i, :] - ideal_best) ** 2))
            distance_worst = math.sqrt(sum((d[i, :] - ideal_worst) ** 2))
            score = distance_worst / (distance_best + distance_worst)
            scores.append(score)

        # Debug: Print scores
        print("Scores:", scores)

        # Add scores and ranks to the original dataset
        self.data["Topsis Score"] = scores
        self.data["Rank"] = self.data["Topsis Score"].rank(ascending=False).astype(int)

        return self.data

def main():
    input_file = r"/content/102203090_data.csv"
    output_file = r"C:\Users\ANTARA SACHDEV\OneDrive\Documents\102203090_result.xlsx"

    # Load the dataframe to determine the number of features
    df = pd.read_csv(input_file)
    num_features = len(df.columns) - 1  # Subtract 1 to exclude the first column (assuming it's an identifier)

    # Adjust weights and impacts based on the actual number of features
    # Ensure weights and impacts have the same length as num_features
    weights = [1, 1, 2, 3] # Original weights
    weights = weights[:num_features] + [1] * (num_features - len(weights)) # Extend with 1s if necessary
    impacts = ["+", "+", "-", "+"] # Original impacts
    impacts = impacts[:num_features] + ["+"] * (num_features - len(impacts)) # Extend with "+" if necessary

    # Validate weights and impacts - This validation is now redundant
    # if len(weights) != len(impacts):
    #     print("Error: The number of weights and impacts must match.")
    #     exit(1)
    # if len(weights) != num_features:
    #     print(f"Error: The number of weights and impacts must match the number of features in the data ({num_features}).")
    #     exit(1)

    # Run Topsis and save output
    topsis = Topsis(input_file)
    result = topsis.evaluate(weights, impacts)

    # Debug: Print result before saving
    print("Result DataFrame:\n", result)

    # Save output
    result.to_excel(output_file, index=False, engine='openpyxl')
    print(f"Output saved to: {output_file}")

main()